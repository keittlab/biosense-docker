#!/usr/bin/env python3

import os
import configparser
from sqlalchemy import create_engine, Column, Integer, String, Float, DateTime
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from sqlalchemy.exc import SQLAlchemyError
from datetime import datetime
import argparse
import subprocess

# Activate the virtual environment
venv_path = '/home/biosense/biosense_venv/bin/activate_this.py'
if os.path.exists(venv_path):
    with open(venv_path) as file_:
        exec(file_.read(), {'__file__': venv_path})

# Function to read configuration with error handling
def read_config(config_file):
    config = configparser.ConfigParser()
    try:
        config.read(config_file)
        if not config.sections():
            raise Exception("Configuration file is empty or not found.")
        return config
    except Exception as e:
        print(f"Error reading configuration file: {e}")
        sys.exit(1)

# Function to check if recording service is active
def is_service_active(service_name):
    status = subprocess.run(['systemctl', 'is-active', '--quiet', service_name])
    return status.returncode == 0

# Parse command-line arguments
parser = argparse.ArgumentParser(description="BirdNET Data Migration Service")
parser.add_argument('--config', type=str, default='/etc/biosense/record-and-analyze-sound.conf', help="Path to configuration file")
args = parser.parse_args()

# Read configuration
config_file = args.config
config = read_config(config_file)

DB_PATH = config.get('DEFAULT', 'DB_PATH', fallback='/home/biosense/datastore/birdnet_results.db')
DB_HOST = config.get('DEFAULT', 'DB_HOST', fallback='10.123.0.1')
DB_PORT = config.getint('DEFAULT', 'DB_PORT', fallback=5432)
DB_NAME = config.get('DEFAULT', 'DB_NAME', fallback='biosense')
DB_USER = config.get('DEFAULT', 'DB_USER', fallback='biosense')
DB_PASSWORD = config.get('DEFAULT', 'DB_PASSWORD', fallback='biosense')

# SQLAlchemy setup
Base = declarative_base()

class Detection(Base):
    __tablename__ = 'birdnet_detections'
    id = Column(Integer, primary_key=True, autoincrement=True)
    sci_name = Column(String, nullable=False)
    com_name = Column(String, nullable=False)
    confidence = Column(Float)
    start_time = Column(Float)
    end_time = Column(Float)
    file_path = Column(String)
    latitude = Column(Float)
    longitude = Column(Float)
    created_at = Column(DateTime, default=datetime.utcnow)

def get_engine(db_type, db_path=None, db_host=None, db_port=None, db_name=None, db_user=None, db_password=None):
    if db_type == 'postgresql':
        return create_engine(f'postgresql+psycopg2://{db_user}:{db_password}@{db_host}:{db_port}/{db_name}')
    else:
        return create_engine(f'sqlite:///{db_path}')

def create_session(engine):
    Session = sessionmaker(bind=engine)
    return Session()

# Create engines and sessions for both SQLite and PostgreSQL
sqlite_engine = get_engine('sqlite', DB_PATH)
sqlite_session = create_session(sqlite_engine)
postgres_engine = get_engine('postgresql', None, DB_HOST, DB_PORT, DB_NAME, DB_USER, DB_PASSWORD)
postgres_session = create_session(postgres_engine)

Base.metadata.create_all(sqlite_engine)
Base.metadata.create_all(postgres_engine)

def migrate_data():
    try:
        # Fetch data from SQLite
        sqlite_data = sqlite_session.query(Detection).all()
        if sqlite_data:
            for detection in sqlite_data:
                postgres_detection = Detection(
                    sci_name=detection.sci_name,
                    com_name=detection.com_name,
                    confidence=detection.confidence,
                    start_time=detection.start_time,
                    end_time=detection.end_time,
                    file_path=detection.file_path,
                    latitude=detection.latitude,
                    longitude=detection.longitude,
                    created_at=detection.created_at
                )
                postgres_session.add(postgres_detection)
            postgres_session.commit()
            # Delete data from SQLite after successful migration
            sqlite_session.query(Detection).delete()
            sqlite_session.commit()
            print("Data migrated from SQLite to PostgreSQL")
    except SQLAlchemyError as e:
        print(f"Error during data migration: {e}")
        postgres_session.rollback()
        sqlite_session.rollback()

if __name__ == "__main__":
    # Check if recording service is active before starting migration
    if is_service_active('recording.service'):
        migrate_data()
    else:
        print("Recording service is not active. Data migration aborted.")
