#!/usr/bin/env python3

import os
import time
import signal
import sys
from datetime import datetime
from sqlalchemy import create_engine, Column, Integer, String, Float, DateTime, Index
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
import configparser
from birdnetlib import Recording
from birdnetlib.analyzer import Analyzer
from pprint import pprint

# Activate the virtual environment
venv_path = '/home/biosense/biosense_venv/bin/activate_this.py'
if os.path.exists(venv_path):
    with open(venv_path) as file_:
        exec(file_.read(), {'__file__': venv_path})

# Function to read configuration with error handling
def read_config(config_file):
    config = configparser.ConfigParser()
    try:
        config.read(config_file)
        if not config.sections():
            raise Exception("Configuration file is empty or not found.")
        return config
    except Exception as e:
        print(f"Error reading configuration file: {e}")
        sys.exit(1)

# Read configuration
config_file = '/etc/biosense/run-birdnet.conf'
config = read_config(config_file)

RECORDING_DIR = config.get('DEFAULT', 'RECORDING_DIR', fallback='/home/biosense/datastore/sounds_recordings/')
EXPORT_DIR = config.get('DEFAULT', 'EXPORT_DIR', fallback='/home/biosense/datastore/sound_analysis_results/')
SEGMENT_LENGTH = config.getint('DEFAULT', 'SEGMENT_LENGTH', fallback=3)
DB_TYPE = config.get('DEFAULT', 'DB_TYPE', fallback='postgresql')  # or 'sqlite'
DB_PATH = config.get('DEFAULT', 'DB_PATH', fallback='/home/biosense/datastore/birdnet_results.db')  # For SQLite
DB_HOST = config.get('DEFAULT', 'DB_HOST', fallback='10.123.0.1')  # For PostgreSQL
DB_PORT = config.getint('DEFAULT', 'DB_PORT', fallback=5432)  # For PostgreSQL
DB_NAME = config.get('DEFAULT', 'DB_NAME', fallback='biosense')
DB_USER = config.get('DEFAULT', 'DB_USER', fallback='biosense')  # For PostgreSQL
DB_PASSWORD = config.get('DEFAULT', 'DB_PASSWORD', fallback='biosense')  # For PostgreSQL

# Get latitude and longitude from environment variables
LATITUDE = float(os.getenv('LATITUDE', '0.0'))
LONGITUDE = float(os.getenv('LONGITUDE', '0.0'))

# SQLAlchemy setup
Base = declarative_base()

class Detection(Base):
    __tablename__ = 'birdnet_detections'
    id = Column(Integer, primary_key=True, autoincrement=True)
    sci_name = Column(String, nullable=False)
    com_name = Column(String, nullable=False)
    confidence = Column(Float)
    start_time = Column(Float)
    end_time = Column(Float)
    file_path = Column(String, nullable=True)
    latitude = Column(Float)
    longitude = Column(Float)
    created_at = Column(DateTime, default=datetime.utcnow)

Index('idx_sci_name', Detection.sci_name)

def get_engine(db_type, db_path, db_host, db_port, db_name, db_user, db_password):
    if db_type == 'postgresql':
        return create_engine(f'postgresql+psycopg2://{db_user}:{db_password}@{db_host}:{db_port}/{db_name}')
    else:
        return create_engine(f'sqlite:///{db_path}')

def create_session(engine):
    Session = sessionmaker(bind=engine)
    return Session()

# Create engines and sessions for both SQLite and PostgreSQL
engine = get_engine(DB_TYPE, DB_PATH, DB_HOST, DB_PORT, DB_NAME, DB_USER, DB_PASSWORD)
session = create_session(engine)

Base.metadata.create_all(engine)

def on_analyze_complete(recording):
    print(f"Analyzed: {recording.path}")
    pprint(recording.detections)
    extract_detected_segments(recording, EXPORT_DIR, SEGMENT_LENGTH)

def on_error(recording, error):
    print(f"Error: {error} in {recording.path}")

def extract_detected_segments(recording, export_dir, segment_length=3):
    if not os.path.exists(export_dir):
        os.makedirs(export_dir)

    for detection in recording.detections:
        start_time = detection['start_time']
        end_time = detection['end_time']
        common_name = detection['common_name'].replace(" ", "_")
        confidence = detection['confidence']
        
        # Ensure each segment is exactly 3 seconds long
        current_start = start_time
        while current_start + segment_length <= end_time:
            segment_filename = f"{export_dir}/{common_name}_{current_start:.0f}s-{current_start + segment_length:.0f}s_conf{confidence:.2f}.wav"
            recording.extract_audio_segment(current_start, current_start + segment_length, filename=segment_filename)
            print(f"Extracted segment: {segment_filename}")
            
            # Save detection to the database
            detection_data = Detection(
                sci_name=detection['scientific_name'],
                com_name=detection['common_name'],
                confidence=detection['confidence'],
                start_time=current_start,
                end_time=current_start + segment_length,
                file_path=segment_filename,
                latitude=LATITUDE,
                longitude=LONGITUDE
            )
            session.add(detection_data)
            current_start += segment_length / 2
        session.commit()

def analyze_recordings():
    analyzer = Analyzer()

    while True:
        for filename in os.listdir(RECORDING_DIR):
            if filename.endswith(".wav"):
                filepath = os.path.join(RECORDING_DIR, filename)
                recording = Recording(analyzer, filepath, lat=LATITUDE, lon=LONGITUDE)
                recording.analyze()
                on_analyze_complete(recording)
                os.remove(filepath)  # Remove the file after processing
        time.sleep(10)

def main():
    def signal_handler(sig, frame):
        sys.exit(0)

    signal.signal(signal.SIGINT, signal_handler)

    analyze_recordings()

if __name__ == "__main__":
    main()
