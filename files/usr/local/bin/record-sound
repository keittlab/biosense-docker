#!/usr/bin/env python3

import os
import shutil
import signal
import sys
import toml
import logging
import time
from logging.handlers import RotatingFileHandler
from subprocess import Popen, PIPE
from datetime import datetime
import re

# Configure logging
log_dir = "/var/log/biosense/"
log_file = os.path.join(log_dir, "record-sound.log")
log_handler = RotatingFileHandler(
    log_file, maxBytes=1 * 1024 * 1024, backupCount=5
)  # 1 MB per file, 5 backup files
logging.basicConfig(
    level=logging.INFO,
    handlers=[log_handler],
    format="%(asctime)s - %(levelname)s - %(message)s",
)


# Function to read configuration with error handling
def read_config(config_file):
    try:
        if not os.path.exists(config_file):
            raise Exception(f"Configuration file does not exist: {config_file}")

        logging.info(f"Reading configuration file: {config_file}")
        with open(config_file, "r") as f:
            content = toml.load(f)

        if not content:
            raise Exception("Configuration file is empty or not found.")

        return content["DEFAULT"]
    except Exception as e:
        logging.error(f"Error reading configuration file: {e}")
        sys.exit(1)


# Read configuration
config_file = "/etc/biosense/record-sound.conf"
config = read_config(config_file)

RECORDING_DIR = config.get(
    "RECORDING_DIR", "/home/biosense/datastore/sound_recordings/"
)
RECORDING_DURATION_MINUTES = int(
    config.get("RECORDING_DURATION_MINUTES", 15)
)  # Minutes
SLEEP_INTERVAL_SECONDS = int(
    config.get("SLEEP_INTERVAL_SECONDS", 5)
)  # Sleep interval in seconds
RATE = int(config.get("RATE", 48000))  # Sample rate in Hz
DEFAULT_FORMAT = config.get("DEFAULT_FORMAT", "S24_3LE")  # Configurable default format
DEFAULT_CHANNELS = int(
    config.get("DEFAULT_CHANNELS", 2)
)  # Configurable default number of channels


def get_hostname():
    hostname = os.uname().nodename
    return hostname.replace("-", "_")


# Function to automatically detect hardware ID
def get_hw_params():
    try:
        # List available capture devices
        process = Popen(["arecord", "-l"], stdout=PIPE, stderr=PIPE, text=True)
        stdout, stderr = process.communicate()
        logging.info(f"arecord -l output: {stdout}")

        if process.returncode != 0:
            logging.error(f"Error in arecord -l: {stderr}")
            return None

        # Example output parsing: card 1, device 0
        match = re.search(r"card (\d+):.*device (\d+):", stdout)
        if match:
            card = match.group(1)
            device = match.group(2)
            hw_id = f"hw:{card},{device}"
            logging.info(f"Detected hardware ID: {hw_id}")
            return hw_id
        else:
            logging.error("No capture device found.")
            return None
    except Exception as e:
        logging.error(f"Error detecting hardware: {e}")
        return None


# Function to detect supported format and channels using --dump-hw-params or fallback to arecord -L
def get_supported_format_and_channels(hw_id):
    try:
        # Add -f S24_3LE to prevent defaulting to 8-bit format
        process = Popen(
            [
                "arecord",
                "-D",
                hw_id,
                "--dump-hw-params",
                "-f",
                DEFAULT_FORMAT,
                "-d",
                "0",
            ],
            stdout=PIPE,
            stderr=PIPE,
            text=True,
        )
        stdout, stderr = process.communicate()

        logging.info(f"arecord --dump-hw-params output: {stdout}")
        if process.returncode != 0:
            logging.error(f"Error in arecord --dump-hw-params: {stderr}")
            return (
                DEFAULT_FORMAT,
                DEFAULT_CHANNELS,
            )  # Default format and channels in case of error

        # Search for available formats in the output
        format_match = re.search(r"Available formats:\s*-\s*(\S+)", stdout)
        format_supported = (
            format_match.group(1) if format_match else DEFAULT_FORMAT
        )  # Default to config format

        # Search for the supported number of channels
        channels_match = re.search(r"CHANNELS:\s*(\d+)", stdout)
        channels_supported = (
            int(channels_match.group(1)) if channels_match else DEFAULT_CHANNELS
        )  # Default to config channels

        logging.info(
            f"Detected supported format: {format_supported}, channels: {channels_supported}"
        )
        return format_supported, channels_supported
    except Exception as e:
        logging.error(f"Error detecting hardware format and channels: {e}")
        return (
            DEFAULT_FORMAT,
            DEFAULT_CHANNELS,
        )  # Default to config format and channels if detection fails


def start_recording():
    try:
        latitude = float(os.getenv("LATITUDE", "0"))
        longitude = float(os.getenv("LONGITUDE", "0"))
    except ValueError:
        logging.error("Invalid latitude or longitude values. Using default (0, 0).")
        latitude = 0
        longitude = 0

    lat_direction = "N" if latitude >= 0 else "S"
    lon_direction = "E" if longitude >= 0 else "W"
    latitude = abs(latitude)
    longitude = abs(longitude)
    lat_str = f"{latitude:.6f}".replace(".", "_")
    lon_str = f"{longitude:.6f}".replace(".", "_")
    formatted_lat_lon = f"{lat_str}{lat_direction}_{lon_str}{lon_direction}"

    hostname = get_hostname()

    # Detect hardware ID and supported format and channels
    hw_id = get_hw_params()
    if hw_id is None:
        logging.error("Unable to detect hardware. Exiting.")
        sys.exit(1)

    FORMAT, CHANNELS = get_supported_format_and_channels(
        hw_id
    )  # Get the supported format and channels

    # Get timestamp just before launching arecord
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    file_pattern = os.path.join(
        RECORDING_DIR, f"arecord_{hostname}_{formatted_lat_lon}_{timestamp}.wav"
    )

    # Use detected hardware ID, format, and channels
    arecord_command = [
        "arecord",
        "-D",
        hw_id,
        "-f",
        FORMAT,
        f"-c{CHANNELS}",
        f"-r{RATE}",
        "-t",
        "wav",
        "--max-file-time",
        str(RECORDING_DURATION_MINUTES * 60),
        file_pattern,  # Convert minutes to seconds
    ]
    logging.info(f"Starting recording with command: {' '.join(arecord_command)}")

    # Run the process
    process = Popen(arecord_command, stdout=PIPE, stderr=PIPE, text=True)

    def signal_handler(sig, frame):
        logging.info("Terminating recording process.")
        process.terminate()
        process.wait()
        logging.info("Recording process terminated.")
        sys.exit(0)

    signal.signal(signal.SIGINT, signal_handler)

    while True:
        time.sleep(SLEEP_INTERVAL_SECONDS)
        if process.poll() is not None:  # Process has finished
            if process.returncode != 0:  # Non-zero exit code indicates failure
                stderr = process.stderr.read()
                logging.error(
                    f"'arecord' failed with return code {process.returncode}: {stderr}"
                )
                sys.exit(1)
            else:
                logging.info("Recording completed successfully.")
                break


def main():
    if not os.path.exists(RECORDING_DIR):
        os.makedirs(RECORDING_DIR)
        logging.info(f"Created recording directory: {RECORDING_DIR}")

    start_recording()


if __name__ == "__main__":
    main()
