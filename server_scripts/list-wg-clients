#!/bin/bash

# Function to display usage
usage() {
  echo "Usage: $0 [-i | --ips-only] [-f | --filter FILTERS]"
  echo "  -i, --ips-only          Output only the IP addresses of the connected clients"
  echo "  -f, --filter FILTERS    Filter IP addresses by specified patterns (comma-separated)"
  echo "                          Example: -f '3' matches IPs like x.x.x.3"
  echo "                          Example: -f '0.3' matches IPs like x.x.0.3"
  echo "                          Example: -f '0-1.0-255' matches IPs like x.x.0.x and x.x.1.x"
  echo "  -h, --help              Display this help message"
  exit 1
}

# Function to match IP against filters
ip_matches_filter() {
  local ip="$1"
  local filters="$2"

  IFS=. read -r i1 i2 i3 i4 <<< "$ip"

  IFS=, read -ra filter_list <<< "$filters"
  for filter in "${filter_list[@]}"; do
    if [[ "$filter" == *.* ]]; then
      IFS=. read -r f3 f4 <<< "$filter"
      if [[ "$f3" == *-* ]]; then
        IFS=- read f3_start f3_end <<< "$f3"
        if [[ "$i3" -ge "$f3_start" && "$i3" -le "$f3_end" ]]; then
          if [[ "$f4" == *-* ]]; then
            IFS=- read f4_start f4_end <<< "$f4"
            if [[ "$i4" -ge "$f4_start" && "$i4" -le "$f4_end" ]]; then
              echo "$ip"
              return
            fi
          elif [[ "$i4" == "$f4" ]]; then
            echo "$ip"
            return
          fi
        fi
      elif [[ "$i3" == "$f3" ]]; then
        if [[ "$f4" == *-* ]]; then
          IFS=- read f4_start f4_end <<< "$f4"
          if [[ "$i4" -ge "$f4_start" && "$i4" -le "$f4_end" ]]; then
            echo "$ip"
            return
          fi
        elif [[ "$i4" == "$f4" ]]; then
          echo "$ip"
          return
        fi
      fi
    elif [[ "$filter" == *-* ]]; then
      IFS=- read f3_start f3_end <<< "$filter"
      if [[ "$i3" -ge "$f3_start" && "$i3" -le "$f3_end" ]]; then
        echo "$ip"
        return
      fi
    else
      if [[ "$i4" == "$filter" ]]; then
        echo "$ip"
        return
      fi
    fi
  done
}

# Parse command-line arguments
IPS_ONLY=false
FILTERS=""
while [[ "$1" != "" ]]; do
  case $1 in
    -i | --ips-only )  IPS_ONLY=true
                       ;;
    -f | --filter )    shift
                       FILTERS="$1"
                       ;;
    -h | --help )      usage
                       ;;
    * )                usage
                       ;;
  esac
  shift
done

# Get the list of clients connected to the WireGuard interface
WG_INTERFACE="wg0"

# Use wg command to get the allowed IPs
WG_STATUS=$(wg show $WG_INTERFACE allowed-ips)

# Extract the IP addresses and strip the subnet mask
CLIENT_IPS=$(echo "$WG_STATUS" | grep -oP '(\d+\.\d+\.\d+\.\d+)/\d+' | sed 's|/.*||')

# Filter IPs if filter option is provided
if [ -n "$FILTERS" ]; then
  CLIENT_IPS=$(echo "$CLIENT_IPS" | while read -r ip; do ip_matches_filter "$ip" "$FILTERS"; done)
fi

if [ "$IPS_ONLY" = true ]; then
  # Print the client IP addresses if there are any
  if [ -n "$CLIENT_IPS" ]; then
    echo "$CLIENT_IPS"
  fi
else
  # Use wg command to get the current status
  WG_STATUS=$(wg show $WG_INTERFACE)

  if [ -n "$FILTERS" ]; then
    # Filter the full status output based on the filtered IPs
    FILTERED_STATUS=""
    for ip in $CLIENT_IPS; do
      FILTERED_STATUS+=$(echo "$WG_STATUS" | awk -v ip="$ip" '
        /peer/ {peer=$0; peer_printed=0}
        /allowed ips: / {
          if ($3 ~ ip) {
            if (!peer_printed) {
              print peer
              peer_printed=1
            }
            print $0
            getline
            print $0
            getline
            print $0
          }
        }
      ')
    done
    if [ -n "$FILTERED_STATUS" ]; then
      echo "Connected clients on interface $WG_INTERFACE:"
      echo "$FILTERED_STATUS"
    fi
  else
    # Extract the client information
    CLIENTS=$(echo "$WG_STATUS" | grep -E "peer|allowed ips|latest handshake|transfer" | sed 's/^/  /')
    echo "Connected clients on interface $WG_INTERFACE:"
    echo "$CLIENTS"
  fi
fi
